# Blinking LED bare metal C example

![](blinking.gif)

This code shows how to blink the LED for the Arduino Mega Rev3 on and off in 1 second intervals directly (in bare metal C), without the help of the Arduino IDE. In addition, it returns strings via USART0 through the serial line.

To run the example, connect the board to your computer and run `make` then `make deploy DEV=<device>`, e.g. `make deploy DEV=/dev/tty.usbmodem143101` (you may have to run `avrdude` as root). Use `make test` to disable the `_delay_ms()` function during debugging.

To see the returned strings as they arrive, run `screen <device> 115200` (exit by pressing `Ctrl` + `A` + `K`, release and then press `y`)

- On Windows you can use [PuTTY](https://www.putty.org) to send and receive serial data (use `Ctrl + J` to send data)

> Note: dump.txt was generated by running `avr-objdump -d blink_led.elf > dump.txt`

If using the Arduino IDE, the code would look something like this:

```cpp
// the setup function runs once when you press reset or power the board
void setup() {
    // initialize digital pin LED_BUILTIN as an output
    pinMode(LED_BUILTIN, OUTPUT);
}

// the loop function runs over and over again forever
void loop() {
    digitalWrite(LED_BUILTIN, HIGH);  // turn the LED on (HIGH is the voltage level)
    delay(1000);                      // wait one second
    Serial.println("Hello");          // print "Hello\n"
    digitalWrite(LED_BUILTIN, LOW);   // turn the LED off by making the voltage LOW
    delay(1000);                      // wait one second
    Serial.println("World!");         // print "World!\n"
}
```

This uses the Arduino language (a variant of C++).

## Dependencies

You will need to install the AVR GCC toolchain as well as the `avrdude` utility to flash the code to the board's memory.

macOS (using Homebrew):

```bash
brew tap osx-cross/avr
brew install avr-gcc avr-binutils avrdude # avr-libc included with avr-gcc
```

Linux (Ubuntu/Debian):

```bash
sudo apt update && sudo apt install gcc-avr avr-libc binutils-avr avrdude
```

Some helpful links for the Arduino Mega Rev3:

- [https://docs.arduino.cc/hardware/mega-2560/](https://docs.arduino.cc/hardware/mega-2560/)
    - This page includes the pinout PDF, which is also in this repository
- [ATmega2560 data sheet](https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/ATmega640-1280-1281-2560-2561-Datasheet-DS40002211A.pdf)
    - This is the MCU chip in the board
- [AVR Instruction Set Manual](https://ww1.microchip.com/downloads/en/DeviceDoc/AVR-InstructionSet-Manual-DS40002198.pdf)

Advanced:

- I had to change the flags to `avrdude` to use the AVRISP mkII programmer instead of the default Arduino bootloader using the STK500 v1 protocol, and with that disabling auto-erase for flash memory (`-D`) and also not performing a chip erase at the start (`-e`)
- I looked into using Rust for this project. There's good news and bad news:
    - The good news is that there appears to be community (unofficial) AVR support for at least the ATmega328 chip found in an Arduino Uno Rev3 (link [here](https://doc.rust-lang.org/nightly/rustc/platform-support.html#tier-3))
    - The bad news is that it doesn't allow the Rust standard library `libstd` to be loaded ("`no_std`"). This includes the Rust runtime, which enforces stack overflow protection (link [here](https://docs.rust-embedded.org/book/intro/no-std.html#the-libstd-runtime))
- This example shows how to extract the contents of the flash memory with `avrdude`
    - Normally you wouldn't need to pass `-L` to `disasm`, but there was an issue with undefined labels
    - It also shows that `avr-objcopy` is unnecessary, as the microcontroller programmer AVRISP mkII understands the ELF file format
